# import math

# finds where the function becomes 0 in [a,b] using bolzano
fn bisection (func: num -> num, a: num, b: num)
    start = a
    end = b
    if func(a) == 0  # one of the a or b is a root for the function
        return a
    elif func(b) == 0
        return b
    elif func(a) * func(b) > 0  # if none of these are root and they are both positive or negative,
        # then his algorithm can't find the root
        raise ("couldn't find root in [a,b]")
    else
        mid = start + (end - start) / 2
        while abs(start - mid) > 10**-7  # until we achieve precise equals to 10^-7
            if func(mid) == 0
                return mid
            elif func(mid) * func(start) < 0
                end = mid
            else
                start = mid
            mid = start + (end - start) / 2
        return mid


fn f (x: num)
    return math.pow(x, 3) - 2*x - 5