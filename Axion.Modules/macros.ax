# This file is a part of Axion built-ins.
# It contains all standard macro definitions.

macro do-while-statement (
    scope:     Scope,
    condition: Infix
)
    syntax = $('do', scope, ('while' | 'until'), condition)
    
    if syntax[2] == 'while'
        condition = {{ not $condition }}
    
    return {{
        while true {
            $scope
            if $condition {
                break
            }
        }
    }}


macro until-statement (
    scope:     Scope,
    condition: Infix
)
    syntax = $('until', condition, scope)
    
    return {{
        while not $condition {
            $scope
        }
    }}


macro for-in-statement (
    item:     Atom,
    iterable: Infix,
    scope:    Scope
)
    syntax = $('for', item, 'in', iterable, scope)
    
    return {{ }}


macro for-index-statement (
    init:      Any,
    condition: Infix,
    step:      Infix,
    scope:     Scope
)
    syntax = $('for', init, ',', condition, ',', step, scope)
    
    return {{
        $init
        while $condition {
            $scope
            $step
        }
    }}


macro unless-statement (
    condition:  Infix,
    then-scope: Scope,
    else-scope: Scope
)
    syntax = $('unless', condition, then-scope, ['else', else-scope])
    
    return {{
        if not $condition {
            $scope
        }
        else {
            $else-scope
        }
    }}


macro raise-statement (
    type-name: TypeName,
    args-lst:  Infix
)
    syntax = $('raise', type-name, ['(', [arg, [{',', arg}]], ')'])
    
    return {{ }}


macro match-expression (
    target:  Any,
    pattern: Infix,
    value:   Any
)
    syntax = $(
        target, 'match', {pattern, ':', value}
    )

    return {{ }}


macro object-initializer-expression (
    type-name:   TypeName,
    arg:         Infix,
    initializer: Infix,
)
    syntax = $(
        'new',
        (
            ('(', arg, [{',', arg}], [','], ')')
          | (
                type-name,
                ['(', [arg, [{',', arg}], [',']], ')'],
                ['{', [initializer, [{',', initializer}], [',']], '}']
            )
        )
    )

    return {{ }}


macro list-init-expression (
    item: Infix
)
    syntax = $('[', [item, [{',', item}], [',']], ']')

    return {{ }}



macro map-init-expression (
    key:   Infix,
    value: Infix,
)
    syntax = $(
        '{',
        [
            key, ':', value,
            [{',', key, ':', value}],
            [',']
        ],
        '}'
    )

    return {{ }}


macro set-init-expression (
    value: Infix,
)
    syntax = $(
        '{',
        value,
        [{',', value}],
        [','],
        '}'
    )

    return {{ }}


#====================
# x times
#     do-smth()
#====================
# uniq-name = 0
# while uniq-name < x
#     do-smth()
#     uniq-name++
#====================
macro times-statement (
    counter-end:  Infix,
    scope:        Scope,
    counter-name: Name
)
    syntax = $(counter-end, 'times', scope)
    
    # counter-name = new Name()
    
    return {{
        $counter-name = 0
        while $counter-name < $counter-end {
            $scope
            $counter-name++
        }
    }}


macro with-statement (
    expr:  Any,
    value: Name,
    init:  Expression,
    scope: Scope
)
    syntax = $('with', expr, scope)

    if value is Name
        name = value
    else # l = r
        init = value
        name = value.Left

    return {{
        $init
        try {
            $scope
        }
        finally {
            $name.destroy()
        }
    }}