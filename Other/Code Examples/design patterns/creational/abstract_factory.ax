# Абстрактная фабрика знает обо всех абстрактных типах
# продуктов.
abstract class GUI:
    # Этот паттерн предполагает, что у вас есть несколько семейств
    # продуктов, находящихся в отдельных иерархиях классов
    # (Button/Checkbox). Продукты одного семейства должны иметь
    # общий интерфейс.
    class Element:
        # Отрисовать элемент.
        render(): pass

        # Навесить на элемент обработчик событий.
        on-mouse-over(func function): pass

    class Button <- Element: pass

    class Checkbox <- Element: pass

    class Dialog <- Element: pass

######################################
# EXAMPLE #1: DEFAULT TYPE OF FACTORY.
######################################

# Каждая конкретная фабрика знает и создаёт только продукты
# своей вариации.
class Windows-GUI <- GUI:
    class Button:
        render():
            # Отрисовать кнопку в стиле Windows.

        on-mouse-over():
            # Навесить на кнопку обработчик событий Windows.

    class Checkbox:
        render():
            # Отрисовать чекбокс в стиле Windows.

        on-mouse-over():
            # Навесить на чекбокс обработчик событий Windows.

    class Dialog:
        render():
            # Отрисовать окно в браузере.

        on-mouse-over():
            # Навесить на окно обработчик событий.

#####################################################################
# EXAMPLE #2: SPLIT FACTORY TO PARTS TO MOVE THEM TO DIFFERENT FILES.
#####################################################################

# Несмотря на то, что фабрики оперируют конкретными классами,
# их методы возвращают абстрактные типы продуктов. Благодаря
# этому фабрики можно взаимозаменять, не изменяя клиентский
# код.
partial class Mac-GUI <- GUI:
    class Button:
        render():
            # Отрисовать кнопку в стиле macOS.

        on-mouse-over():
            # Навесить на чекбокс обработчик событий.

partial class Mac-GUI <- GUI:
    class Checkbox:
        render():
            # Отрисовать чекбокс в стиле macOS.

        on-mouse-over():
            # Навесить на чекбокс обработчик событий.

partial class Mac-GUI <- GUI:
    class Dialog:
        render():
            # Отрисовать окно в браузере.

        on-mouse-over():
            # Навесить на окно обработчик событий.

#####################################################################
# EXAMPLE #3: SPLIT FACTORY TO PARTS TO MOVE THEM TO DIFFERENT FILES.
#####################################################################

class Web-GUI <- GUI: pass

class Web-GUI.Button:
    render():
        # Отрисовать кнопку в браузере.

    on-mouse-over():
        # Навесить на чекбокс обработчик событий.

class Web-GUI.Checkbox:
    render():
        # Отрисовать чекбокс в браузере.

    on-mouse-over():
        # Навесить на чекбокс обработчик событий.

class Web-GUI.Dialog:
    render():
        # Отрисовать окно в браузере.

    on-mouse-over():
        # Навесить на окно обработчик событий.

######################################
# Client code.
######################################

# Для кода, использующего фабрику, не важно, с какой конкретно
# фабрикой он работает. Все получатели продуктов работают с
# ними через общие интерфейсы.
class Application:
    private:
        GUI    factory
        Button button

    new(GUI factory):
        self.factory = factory

    create-UI()
        button = new factory.Dialog()

    render()
        dialog.render()


# Приложение выбирает тип конкретной фабрики и создаёт её
# динамически, исходя из конфигурации или окружения.
class ApplicationConfigurator:
    start():
        config = read-application-config-file()

        if config.Platform == Platform.Windows:
            factory = Windows-GUI
        elif config.Platform == Platform.Mac:
            factory = Mac-GUI
        elif config.Platform == Platform.Web:
            factory = Web-GUI
        else:
            throw new Exception("Error! Unknown operating system.")

        app = new Application(factory)
